{"meta":{"title":"qmmm61","subtitle":"qmmm61's blog","description":"qmmm61's blog","author":"qmmm61","url":"https://qmmm61.github.io","root":"/"},"pages":[{"title":"about me","date":"2020-07-09T01:34:45.000Z","updated":"2022-10-23T14:46:44.442Z","comments":true,"path":"about/index.html","permalink":"https://qmmm61.github.io/about/","excerpt":"","text":""},{"title":"404 Not Found","date":"2023-05-15T02:07:03.306Z","updated":"2022-10-23T14:46:44.436Z","comments":true,"path":"404.html","permalink":"https://qmmm61.github.io/404","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"categories","date":"2020-07-09T02:05:12.000Z","updated":"2022-10-23T14:46:44.446Z","comments":true,"path":"categories/index.html","permalink":"https://qmmm61.github.io/categories/","excerpt":"","text":""},{"title":"archives","date":"2020-07-09T02:05:40.000Z","updated":"2022-10-23T14:46:44.446Z","comments":true,"path":"archives/index.html","permalink":"https://qmmm61.github.io/archives/","excerpt":"","text":""},{"title":"tags","date":"2020-07-09T02:05:30.000Z","updated":"2022-10-23T14:46:44.462Z","comments":true,"path":"tags/index.html","permalink":"https://qmmm61.github.io/tags/","excerpt":"","text":""}],"posts":[{"title":"hwod面试","slug":"work/interview/hwod","date":"2024-11-24T11:46:45.000Z","updated":"2024-11-24T11:46:45.000Z","comments":false,"path":"work/interview/hwod/","link":"","permalink":"https://qmmm61.github.io/work/interview/hwod/","excerpt":"华为OD面试记录","text":"华为OD面试记录 机试01题目：加敏字符串 题目描述： 给定一个由多个命令字组成的命令字符串: 字符串长度小于等于127字节，只包含大小写字母、数字、下划线和偶数个双引号; 命令字之间以一个或多个下划线进行分割; 可以通过两个双引号来标识包含下划线的命令字或空命令字(仅包含两个引双引号的命令字)双引号不会在命令字内部出现; 仅对指定索引的敏感字段进行加密，替换为*，并删除命令字前后多余的下划线。如果无法找到指定索引的命令字，输出字符串ERROR。 输入描述： 输入为两行，第一行为命令字索引K（从0开始），第二行为命令字符串S。 输出描述： 输出处理后的命令字符串，如果无法找到指定索引的命令字，输出字符串ERROR。 code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566import java.util.*;// 注意类名必须为 Main, 不要有任何 package xxx 信息public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int index = Integer.parseInt(sc.nextLine()); String line = sc.nextLine(); String result = processCommand(index, line); System.out.println(result); &#125; //line 命令行 public static String processCommand(int index, String line) &#123; //加敏结果 StringBuilder result = new StringBuilder(); //sub命令 StringBuilder part = new StringBuilder(); //sub命令数 int count = 0; //是否在引号内 boolean insideQutos = false; for (int i = 0; i &lt; line.length(); i++) &#123; char ch = line.charAt(i); if (ch == &#x27;\\&quot;&#x27;) &#123; //前引号 后引号 insideQutos = !insideQutos; part.append(ch); &#125; else if (!insideQutos &amp;&amp; ch == &#x27;_&#x27;) &#123; if (part.length() &gt; 0) &#123; //sub命令结束 //sub命令有长度，遇到下划线字符，表示此sub命令结束 if (count == index) &#123; //表示是指定index处的sub命令 result.append(&quot;******&quot;); &#125; else &#123; //不是index处的sub命令 result.append(part.toString()); &#125; // result.append(&quot;_&quot;); count++; part.setLength(0); &#125; &#125; else &#123; //引号外，或者引号内非结束位置 part.append(ch); &#125; &#125; //最后一个sub命令 if (part.length() &gt; 0) &#123; if (count == index) &#123; result.append(&quot;******&quot;); &#125; else &#123; result.append(part.toString()); &#125; &#125; else if (result.length() &gt; 0) &#123; result.deleteCharAt(result.length() - 1); &#125; return count &gt;= index ? result.toString() : &quot;ERROR&quot;; &#125;&#125; 机试02题目：字符串解密 题目描述： 给定两个字符串string1和string2。string1是一个被加扰的字符串。string1由小写英文字母（&#39;a&#39;~&#39;z&#39;）和数字字符（&#39;0&#39;~&#39;9&#39;）组成，而加扰字符串由&#39;0&#39;~&#39;9&#39;、&#39;a&#39;~&#39;f&#39;组成。string1里面可能包含0个或多个加扰子串，剩下可能有0个或多个有效子串，这些有效子串被加扰子串隔开。string2是一个参考字符串，仅由小写英文字母（’a’~’z’）组成。 你需要在string1字符串里找到一个有效子串，这个有效子串要同时满足下面两个条件： 这个有效子串里不同字母的数量不超过且最接近于string2里不同字母的数量，即小于或等于string2里不同字母的数量的同时且最大。 这个有效子串是满足条件（1）里的所有子串（如果有多个的话）里字典序最大的一个。如果没有找到合适条件的子串的话，请输出”Not Found”。 输入描述： input_string1input_string2输入为两个字符串，第1行是题目里的string1（被加扰的字符串），第2行是题目里的string2（参考字符串）。 输出描述： output_string输出为一个字符串（有效字符串）。 补充说明：输入字符串string1的长度在1~100000之间，string2的长度在1~500之间。 code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import java.util.*;// 注意类名必须为 Main, 不要有任何 package xxx 信息public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); String str1 = sc.next(); String str2 = sc.next(); System.out.println(getSub(str1, str2)); &#125; public static String getSub(String str1, String str2) &#123; //字符串2的去重字母数 int tCount = uniqueChars(str2); //字符串1去扰后有效子串数组 String[] parts = getValidParts(str1); String res = &quot;Not Found&quot;; //字符串1中的有效子串最大去重字母数 int maxCount = -1; for (String part : parts) &#123; if (!part.isEmpty()) &#123; int pCount = uniqueChars(part); if (pCount &lt;= tCount) &#123; if (pCount &gt; maxCount) &#123; res = part; maxCount = pCount; &#125; &#125; &#125; &#125; return res; &#125; private static String[] getValidParts(String str) &#123; return str.split(&quot;[0-9a-f]+&quot;); &#125; private static int uniqueChars(String s) &#123; Set&lt;Character&gt; set = new HashSet&lt;&gt;(); for (char c : s.toCharArray()) &#123; set.add(c); &#125; return set.size(); &#125;&#125; 机试03题目：符号运算 题目描述： 给定一个表达式，求其分数计算结果 表达式的限制如下： 所有的输入数字皆为正整数(包括0) 仅支持四则运算(+-*/)和括号 结果为整数或分数, 分数必须化为最简格式(比如6, 3&#x2F;4, 7&#x2F;8, 90&#x2F;7) 除数可能为0，如果遇到这种情况，直接输出”ERROR” 输入和最终计算结果中的数字都不会超出整型范围 用例的输入一定合法, 不会出现括号不匹配的情况 输入描述： 字符串格式的表达式，仅支持+-*/，数字可能超过两位，可能带有空格，没有负数 长度小于200个字符 输出描述： 表达式结果，以最简格式表达如果结果为整数，那么直接输出整数如果结果为分数，那么分子分 用例： 11 + 5 * 7 code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162import java.util.*;// 注意类名必须为 Main, 不要有任何 package xxx 信息public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); String expression = sc.nextLine(); String result = calcResult(expression); System.out.println(result); &#125; public static String calcResult(String expr) &#123; //操作数栈 Stack&lt;Fraction&gt; numStack = new Stack&lt;&gt;(); //运算符栈 Stack&lt;Character&gt; signStack = new Stack&lt;&gt;(); //运算符优先级 Map&lt;Character, Integer&gt; priority = new HashMap&lt;&gt;(); priority.put(&#x27;+&#x27;, 1); priority.put(&#x27;-&#x27;, 1); priority.put(&#x27;*&#x27;, 2); priority.put(&#x27;/&#x27;, 2); //表达式字符索引 int i = 0; while (i &lt; expr.length()) &#123; char ch = expr.charAt(i); //判断字符为数字 if (Character.isDigit(ch)) &#123; StringBuilder numStr = new StringBuilder(); while (i &lt; expr.length() &amp;&amp; Character.isDigit(expr.charAt(i))) &#123; numStr.append(expr.charAt(i)); i++; &#125; numStack.push(new Fraction(Integer.parseInt(numStr.toString()))); continue; &#125; //判断字符为运算符 if (ch == &#x27;+&#x27; || ch == &#x27;-&#x27; || ch == &#x27;*&#x27; || ch == &#x27;/&#x27;) &#123; //运算符栈的栈顶运算符优先级大于等于当前运算符，先计算栈顶运算符 while (!signStack.isEmpty() &amp;&amp; signStack.peek() != &#x27;(&#x27; &amp;&amp; priority.get(ch) &lt;= priority.get(signStack.peek())) &#123; compute(numStack, signStack.pop()); &#125; signStack.push(ch); &#125; else if (ch == &#x27;(&#x27;) &#123; //遇到左括号，入运算符栈 signStack.push(ch); &#125; else if (ch == &#x27;)&#x27;) &#123; //遇到右括号，开始运算符栈出栈计算 while (signStack.peek() != &#x27;(&#x27;) &#123; compute(numStack, signStack.pop()); &#125; //再将左括号出运算符栈 signStack.pop(); &#125; i++; &#125; while (!signStack.isEmpty()) &#123; compute(numStack, signStack.pop()); &#125; Fraction result = numStack.pop(); return result.denominator == 1 ? String.valueOf(result.numerator) : result.numerator + &quot;/&quot; + result.denominator; &#125; //运算 private static void compute(Stack&lt;Fraction&gt; numStack, char op) &#123; //从操作数栈取出两个操作数 Fraction b = numStack.pop(); Fraction a = numStack.pop(); //执行四则运算并将结果入操作数栈 switch (op) &#123; case &#x27;+&#x27;: numStack.push(a.add(b)); break; case &#x27;-&#x27;: numStack.push(a.subtract(b)); break; case &#x27;*&#x27;: numStack.push(a.mulitply(b)); break; case &#x27;/&#x27;: if (b.numerator == 0) &#123; numStack.push(new Fraction(0, 1)); &#125; else &#123; numStack.push(a.divide(b)); &#125; break; &#125; &#125;&#125;class Fraction &#123; //分子，分母 int numerator, denominator; public Fraction(int numerator) &#123; this.numerator = numerator; this.denominator = 1; &#125; public Fraction(int numerator, int denominator) &#123; //最大公约数 int gcd = gcd(numerator, denominator); //分子 this.numerator = numerator / gcd; //分母 this.denominator = denominator / gcd; if (this.denominator &lt; 0) &#123; this.numerator = -this.numerator; this.denominator = -this.denominator; &#125; &#125; //分数加法 public Fraction add(Fraction other) &#123; //分子和 int num = this.numerator * other.denominator + this.denominator * other.numerator; //分母 int den = this.denominator * other.denominator; return new Fraction(num, den); &#125; //分数减法 public Fraction subtract(Fraction other) &#123; int num = this.numerator * other.denominator - this.denominator * other.numerator; int den = this.denominator * other.denominator; return new Fraction(num, den); &#125; //分数乘法 public Fraction mulitply(Fraction other) &#123; int num = this.numerator * other.numerator; int den = this.denominator * other.denominator; return new Fraction(num, den); &#125; //分数除法 public Fraction divide(Fraction other) &#123; int num = this.numerator * other.denominator; int den = this.denominator * other.numerator; return new Fraction(num, den); &#125; //最大公约数 private int gcd(int a, int b) &#123; if (b == 0) &#123; return a; &#125; return gcd(b, a % b); &#125; @Override public String toString() &#123; if (this.denominator == 1) &#123; return String.valueOf(this.numerator); &#125; return this.numerator + &quot;/&quot; + this.denominator; &#125;&#125;","categories":[{"name":"work","slug":"work","permalink":"https://qmmm61.github.io/categories/work/"},{"name":"interview","slug":"work/interview","permalink":"https://qmmm61.github.io/categories/work/interview/"}],"tags":[]},{"title":"Everything has to come to an end, sometime...","slug":"log/date/20240526","date":"2024-05-26T14:00:00.000Z","updated":"2024-05-26T14:00:00.000Z","comments":false,"path":"log/date/20240526/","link":"","permalink":"https://qmmm61.github.io/log/date/20240526/","excerpt":"","text":"","categories":[{"name":"journal","slug":"journal","permalink":"https://qmmm61.github.io/categories/journal/"}],"tags":[]},{"title":"第一次出事故","slug":"log/date/20240215","date":"2024-02-15T15:54:00.000Z","updated":"2024-02-15T15:54:00.000Z","comments":false,"path":"log/date/20240215/","link":"","permalink":"https://qmmm61.github.io/log/date/20240215/","excerpt":"","text":"😒😒😒","categories":[{"name":"journal","slug":"journal","permalink":"https://qmmm61.github.io/categories/journal/"}],"tags":[]},{"title":"welcome 2024","slug":"log/date/20240101","date":"2023-12-31T16:00:01.000Z","updated":"2023-12-31T16:00:01.000Z","comments":false,"path":"log/date/20240101/","link":"","permalink":"https://qmmm61.github.io/log/date/20240101/","excerpt":"","text":"新年快乐吧","categories":[{"name":"journal","slug":"journal","permalink":"https://qmmm61.github.io/categories/journal/"}],"tags":[]},{"title":"老胶片翻拍","slug":"photography/film/老胶片翻拍","date":"2023-07-01T01:27:40.000Z","updated":"2023-07-01T01:27:40.000Z","comments":true,"path":"photography/film/老胶片翻拍/","link":"","permalink":"https://qmmm61.github.io/photography/film/%E8%80%81%E8%83%B6%E7%89%87%E7%BF%BB%E6%8B%8D/","excerpt":"","text":"胶片已经是过去式，二十多年前，胶片还是主流，九几年时候拍的照片，当年扫描打印的照片已经受潮长霉，冲洗的胶片还保留着，于是想将胶片再扫描出来数码化，这样就不会坏了。但是经过这二十几年，也没有将胶片很好的保存，胶片受损严重，表面有许多刮痕，钙化灰尘，药面也已经非常薄弱，恐怕扫描出来的效果不会很好。 了解胶片胶片是记录影像的感光元件，并且也是记录影像信息的载体，使用胶片拍照具体分为三个步骤。 拍摄具体就是外界影像的光线通过相机镜头，由相机快门控制，最终到达胶片上，胶片上的感光材料接收并记录在胶片上，拍摄后的胶片保存在暗盒里等待下一个步骤冲洗 冲洗将拍摄并且保存在暗盒里的胶片在暗房里通过一系列药水冲洗，将胶片上感光材料通过冲洗药水定型 扫描将冲洗好的胶片使用专业的扫描仪器或者使用单反数码相机进行翻拍可得到数码化图片文件，也可以打印纸质相片。 胶片的简单分类 黑白与彩色 正片，负片，反转片 胶片画幅大小 这次要翻拍的胶片具体信息是:柯达金100，彩色负片，135画幅想要准备处理的流程是： 胶片修复 翻拍扫描 AI修复 胶片修复查了一些资料，发现胶片修复确实是个麻烦事儿，需要挺多专业设备，且效果也不一定有多好，因此最后只是简单将胶片用棉纸擦拭清洁。贴一下b站找到的一个关于修复老底片的视频老底片的清洁-东胶影厂 翻拍扫描 翻拍或扫描可以使用数码单反相机对着胶片拍摄进行翻拍，也可以使用专业胶片扫描设备扫描胶片，都能得到数码化文件 调色胶片负片需要去色罩，调色等 以上步骤直接找当地提供胶片扫描的店铺最为方便，直接拿到调色好的照片文件。 AI修复扫描出来的文件，更能清楚看见其受损严重，使用AI工具进一步修复。需要修复的问题 胶片上的许多划痕，扫描出来的图片也就有许多划痕没有找到合适的工具，使用PS的修复工具也不太好用，可能是我不太会PS吧。 由于胶片药面薄弱，扫描出来的图片有点模糊了这次需要修复的也是人像，找到许多修复工具主要也是是针对人像，所以只关注人像修复如何对比找到的工具有Upscayl，CodeFormer，TopazPhotoAI其中Upscayl与CodeFormer开源，TopazPhotoAI是收费的测试了Upscayl与CodeFormer，Upscayl提供GUI应用直接安装比较方便，但修复效果不理想CodeFormer需要git clean源码仓库，Python环境，并且使用命令行，提供预训练模型，修复效果还可以，最终使用的就是CodeFormer，并且使用其提供的预训练模型修复。","categories":[{"name":"photograhy","slug":"photograhy","permalink":"https://qmmm61.github.io/categories/photograhy/"},{"name":"film","slug":"photograhy/film","permalink":"https://qmmm61.github.io/categories/photograhy/film/"}],"tags":[]},{"title":"amiibo for totk","slug":"game/nintendo/zelda/totk/amiiboForTotk","date":"2023-06-21T03:24:01.000Z","updated":"2023-06-21T03:24:01.000Z","comments":true,"path":"game/nintendo/zelda/totk/amiiboForTotk/","link":"","permalink":"https://qmmm61.github.io/game/nintendo/zelda/totk/amiiboForTotk/","excerpt":"","text":"intro已发行的“塞尔达传说主题角色”各款Amiibo，以及配合游戏一同发售的新款“王国之泪林克”Amiibo，将适用于王国之泪游戏中。 material 类别 内容 各种蘑菇 酥麻蘑菇，海拉鲁蘑菇，速速蘑菇，天空蘑菇，冰冷蘑菇，精力蘑菇，铠甲蘑菇，光亮蘑菇，毅力蘑菇，潜行蘑菇，大剑蘑菇，暖暖蘑菇，大生命松露 各种药草 酥麻香草，铠甲草，暖暖香草，海拉鲁草，速速紫罗兰，精力草，向阳草，大剑草，潜行草，冰冷香草 各种水果 各种蔬菜 速速胡萝卜，铠甲南瓜 各种鱼类 酥麻鳟鱼，生命鲑鱼，铠甲鲤鱼，铠甲鲷鱼，生命鲈鱼，海拉鲁鲈鱼，大剑鲷鱼，冰冷鳟鱼，精力鲈鱼，大剑鲤鱼，暖暖鳟鱼，潜行鳟鱼 各种肉类 禽肉，高级禽肉，兽肉，高级兽肉 各种矿石 各种宝石 内容 木桶 木箭，苹果，海拉鲁蘑菇 木箱 木箭，木箭x5，木箭x10 铁箱 木箭，木箭x5，烤鲈鱼，烤螃蟹 Super Smash Bros amiiboSeries name pic head tail reward Super Smash Bros. Link 01000000 00040002 素材 各种水果，各种蔬菜，木箭 普通宝箱 骑士之剑，骑士之剑+，士兵盾，骑士盾 稀有宝箱 黄昏之勇者套装，伊波娜，阴影之镜的布料 Young Link 01000000 037c0002 素材 各种肉类，木箭x5 普通宝箱 士兵双手剑，士兵双手剑+ 稀有宝箱 荣蓉牧场的布料，大鼓隆之剑，时之勇者套装 Toon Link 01000100 00160002 素材 各种鱼类，木箭x5 普通宝箱 回旋镖，回旋镖+，骑士之剑，骑士之剑+ 稀有宝箱 赤狮子王的布料，海风回旋镖，风之勇者套装 Zelda 01010000 000e0002 素材 各种药草，各种果蔬 普通宝箱 士兵之弓，骑士之弓 稀有宝箱 黄昏公主的布料，黄昏之弓，星星碎片，钻石 Sheik 01010100 00170002 素材 各种蘑菇，木箭x10 普通宝箱 一心之弓，护心盾，戒心小刀，戒心小刀+ 稀有宝箱 希克的布料，希克的面具 Ganondorf 01020100 001b0002 素材 各种肉类，波克布林的肝脏，莫力布林的肝脏，炸药桶 普通宝箱 格鲁德双手剑，格鲁德双手剑+ 稀有宝箱 魔王的布料，黄昏之大剑，星星碎片，钻石 The Legend of ZeldaTears of the Kingdom amiiboSeries name pic head tail reward Legend Of Zelda Link - Tears of the Kingdom 01000000 04180902 素材 各种蘑菇、木箭 普通宝箱 骑士之剑（18）、骑士之剑+ 稀有宝箱 新式·英杰服的布料 UNOFFICIAL amiiboSeries name pic head tail reward Legend Of Zelda Gerudo King - Tears of the Kingdom 素材 各种肉类 普通宝箱 瘴气之剑（41） 稀有宝箱 Princess Zelda - Tears of the Kingdom 素材 各种药草，各种果蔬 普通宝箱 士兵之剑（12） 稀有宝箱 Breath of the Wild amiiboSeries name pic head tail reward Legend Of Zelda Link - Rider 01000000 03540902 素材 各种蘑菇、木箭*5 普通宝箱 士兵之剑、士兵之剑+ 稀有宝箱 海利亚兜帽的布料 Link - Archer 01000000 03530902 素材 各种鱼类、各种肉类、木箭*5 普通宝箱 士兵之弓（14）、骑士之弓（26） 稀有宝箱 回忆服的布料、古代之刃 Zelda 01010000 03560902 素材 各种草药，各种蔬果 普通宝箱 士兵盾，骑士盾，王族盾 稀有宝箱 各种宝石，星星碎片，海拉鲁公主的布料 Mipha 01070000 035a0902 素材 各种鱼类 普通宝箱 卓拉之枪，卓拉之枪+ 稀有宝箱 卓拉英杰的布料，神兽兵器·雷塔 Daruk 01050000 03580902 素材 各种矿石，各种宝石 普通宝箱 劈石剑，劈石剑+ 稀有宝箱 鼓隆英杰的布料，神兽兵器·鲁达尼亚 Revali 01080000 035b0902 素材 各种果蔬，木箭x5，木箭x10 普通宝箱 飞燕弓，游隼弓 稀有宝箱 利特英杰的布料，神兽兵器·梅德 Urbosa 01060000 03590902 素材 各种肉类 普通宝箱 格鲁德盾，格鲁德匕首，格鲁德匕首+ 稀有宝箱 格鲁德英杰的布料，神兽兵器·娜波力斯 Bokoblin 01410000 035c0902 素材 各种肉类，波克布林的肝脏 普通宝箱 波克弓，波克盾，尖刺波克弓，尖刺波克盾 稀有宝箱 波克布林的布料 Guardian 01400000 03550902 素材 铁箱 普通宝箱 生锈的剑，生锈的双手剑，生锈的枪，生锈的盾 稀有宝箱 古代之刃，古代西卡花纹的布料 Anniversary_ amiiboSeries name pic head tail reward Legend Of Zelda 8-Bit Link 01000000 034f0902 素材 木箭x5，木桶，炸药桶 普通宝箱 士兵盾，骑士盾，骑士之剑，骑士之剑+ 稀有宝箱 点阵的布料，初始之剑，初始之勇者套装 Link - Majora’s Mask 01000000 034c0902 素材 各种蘑菇，木箭x5 普通宝箱 士兵之剑，士兵之剑+，骑士之剑，骑士之剑+ 稀有宝箱 魔吉拉的面具的布料，鬼神大剑，鬼神套装 Link - Ocarina of Time 01000000 034b0902 素材 各种肉类，木箭x5 普通宝箱 士兵双手剑，士兵双手剑+ 稀有宝箱 荣蓉牧场的布料，大鼓隆之剑，时之勇者套装 Link - Skyward Sword 01000000 034e0902 素材 木箭x10，木箱 普通宝箱 士兵盾，骑士盾，骑士之剑，骑士之剑+ 稀有宝箱 剑之精灵的布料，天空的白刃剑，天空之勇者套装 Link - Twilight Princess 01000000 034d0902 素材 各种果蔬，木箭x5 普通宝箱 骑士之剑（18），骑士之剑+，士兵盾，骑士盾 稀有宝箱 黄昏之勇者套装（帽子，裤子，服装），伊波娜，阴影之镜的布料 Toon Link - The Wind Waker 01000100 03500902 素材 各种鱼类，木箭x5 普通宝箱 回旋镖，回旋镖+，骑士之剑，骑士之剑+ 稀有宝箱 赤狮子王的布料，海风回旋镖，风之勇者套装 Toon Zelda - The Wind Waker 01010000 03520902 素材 各种药草，各种果蔬 普通宝箱 士兵盾，骑士盾 稀有宝箱 灭亡王族的布料，海风盾，各种宝石 Link’s Awakening amiiboSeries name pic head tail reward Legend Of Zelda Link - Link’s Awakening 01000000 03990902 素材 木箭x5，木桶，炸药桶 普通宝箱 士兵之剑，士兵之剑+ 稀有宝箱 蛋图案的布料，织梦之勇者套装 Skyward Sword HD amiiboSeries name pic head tail reward Legend Of Zelda Zelda &amp; Loftwing 01010300 04140902 素材 各种药草，各种果蔬 普通宝箱 士兵之弓，骑士之弓 稀有宝箱 女神的布料，各种宝石 Twilight Princess amiiboSeries name pic head tail reward Legend Of Zelda Midna &amp; Wolf Link 01030000 024f0902 素材 各种肉类，烤顶级兽肉，烤顶级禽肉 普通宝箱 稀有宝箱 阴影之镜的布料","categories":[{"name":"game","slug":"game","permalink":"https://qmmm61.github.io/categories/game/"},{"name":"nintendo","slug":"game/nintendo","permalink":"https://qmmm61.github.io/categories/game/nintendo/"},{"name":"zaldar","slug":"game/nintendo/zaldar","permalink":"https://qmmm61.github.io/categories/game/nintendo/zaldar/"},{"name":"totk","slug":"game/nintendo/zaldar/totk","permalink":"https://qmmm61.github.io/categories/game/nintendo/zaldar/totk/"}],"tags":[]}],"categories":[{"name":"work","slug":"work","permalink":"https://qmmm61.github.io/categories/work/"},{"name":"interview","slug":"work/interview","permalink":"https://qmmm61.github.io/categories/work/interview/"},{"name":"journal","slug":"journal","permalink":"https://qmmm61.github.io/categories/journal/"},{"name":"photograhy","slug":"photograhy","permalink":"https://qmmm61.github.io/categories/photograhy/"},{"name":"film","slug":"photograhy/film","permalink":"https://qmmm61.github.io/categories/photograhy/film/"},{"name":"game","slug":"game","permalink":"https://qmmm61.github.io/categories/game/"},{"name":"nintendo","slug":"game/nintendo","permalink":"https://qmmm61.github.io/categories/game/nintendo/"},{"name":"zaldar","slug":"game/nintendo/zaldar","permalink":"https://qmmm61.github.io/categories/game/nintendo/zaldar/"},{"name":"totk","slug":"game/nintendo/zaldar/totk","permalink":"https://qmmm61.github.io/categories/game/nintendo/zaldar/totk/"}],"tags":[]}